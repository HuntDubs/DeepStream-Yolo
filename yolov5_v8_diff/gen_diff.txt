5c5,6
< from utils.torch_utils import select_device
---
> from ultralytics.utils.torch_utils import select_device
> from ultralytics.utils.tal import make_anchors
11c12
<         self.current = 0
---
>         self.current = -1


16,20d16
<         self.num = 0
<         self.nc = 0
<         self.anchors = ''
<         self.masks = []
< 
27,33d22
<     def Focus(self, child):
<         self.current = child.i
<         self.fc.write('\n# Focus\n')
< 
<         self.reorg()
<         self.convolutional(child.conv)
< 
40c29
<     def BottleneckCSP(self, child):
---
>     def C2f(self, child):
42c31
<         self.fc.write('\n# BottleneckCSP\n')
---
>         self.fc.write('\n# C2f\n')
44,45d32
<         self.convolutional(child.cv2)
<         self.route('-2')
47,94c34
<         idx = -3
<         for m in child.m:
<             if m.add:
<                 self.convolutional(m.cv1)
<                 self.convolutional(m.cv2)
<                 self.shortcut(-3)
<                 idx -= 3
<             else:
<                 self.convolutional(m.cv1)
<                 self.convolutional(m.cv2)
<                 idx -= 2
<         self.convolutional(child.cv3)
<         self.route('-1, %d' % (idx - 1))
<         self.batchnorm(child.bn, child.act)
<         self.convolutional(child.cv4)
< 
<     def C3(self, child):
<         self.current = child.i
<         self.fc.write('\n# C3\n')
< 
<         self.convolutional(child.cv2)
<         self.route('-2')
<         self.convolutional(child.cv1)
<         idx = -3
<         for m in child.m:
<             if m.add:
<                 self.convolutional(m.cv1)
<                 self.convolutional(m.cv2)
<                 self.shortcut(-3)
<                 idx -= 3
<             else:
<                 self.convolutional(m.cv1)
<                 self.convolutional(m.cv2)
<                 idx -= 2
<         self.route('-1, %d' % idx)
<         self.convolutional(child.cv3)
< 
<     def SPP(self, child):
<         self.current = child.i
<         self.fc.write('\n# SPP\n')
< 
<         self.convolutional(child.cv1)
<         self.maxpool(child.m[0])
<         self.route('-2')
<         self.maxpool(child.m[1])
<         self.route('-4')
<         self.maxpool(child.m[2])
<         self.route('-6, -5, -3, -1')
---
>         self.c2f(child.m)
127,129c67,68
<         self.get_anchors(child.state_dict(), child.m[0].out_channels)
< 
<         for i, m in enumerate(child.m):
---
>         output_idxs = [0 for _ in range(child.nl)]
>         for i in range(child.nl):
132,133c71,80
<             self.convolutional(m, detect=True)
<             self.yolo(i)
---
>             for j in range(len(child.cv3[i])):
>                 self.convolutional(child.cv3[i][j])
>             self.route('%d' % (-1 - len(child.cv3[i])))
>             for j in range(len(child.cv2[i])):
>                 self.convolutional(child.cv2[i][j])
>             self.route('-1, %d' % (-2 - len(child.cv2[i])))
>             self.shuffle(reshape=[child.no, -1])
>             output_idxs[i] = (-1 + i * (-4 - len(child.cv3[i]) - len(child.cv2[i])))
>         self.route('%s' % str(output_idxs[::-1])[1:-1], axis=1)
>         self.yolo(child)
142,170d88
<     def CBH(self, child):
<         self.current = child.i
<         self.fc.write('\n# CBH\n')
< 
<         self.convolutional(child.conv, act='hardswish')
< 
<     def LC_Block(self, child):
<         self.current = child.i
<         self.fc.write('\n# LC_Block\n')
< 
<         self.convolutional(child.dw_conv, act='hardswish')
<         if child.use_se:
<             self.avgpool()
<             self.convolutional(child.se.conv1, act='relu')
<             self.convolutional(child.se.conv2, act='silu')
<             self.shortcut(-4, ew='mul')
<         self.convolutional(child.pw_conv, act='hardswish')
< 
<     def Dense(self, child):
<         self.current = child.i
<         self.fc.write('\n# Dense\n')
< 
<         self.convolutional(child.dense_conv, act='hardswish')
< 
<     def reorg(self):
<         self.blocks[self.current] += 1
< 
<         self.fc.write('\n[reorg]\n')
< 
210c128
<     def batchnorm(self, bn, act):
---
>     def c2f(self, m):
213c131,132
<         self.get_state_dict(bn.state_dict())
---
>         for x in m:
>             self.get_state_dict(x.state_dict())
215,216c134,145
<         filters = bn.num_features
<         act = self.get_activation(act._get_name())
---
>         n = len(m)
>         shortcut = 1 if m[0].add else 0
>         filters = m[0].cv1.conv.out_channels
>         size = m[0].cv1.conv.kernel_size
>         stride = m[0].cv1.conv.stride
>         pad = m[0].cv1.conv.padding
>         groups = m[0].cv1.conv.groups
>         bias = m[0].cv1.conv.bias
>         bn = True if hasattr(m[0].cv1, 'bn') else False
>         act = 'linear'
>         if hasattr(m[0].cv1, 'act'):
>             act = self.get_activation(m[0].cv1.act._get_name()) 
218c147,154
<         self.fc.write('\n[batchnorm]\n' +
---
>         b = 'batch_normalize=1\n' if bn is True else ''
>         g = 'groups=%d\n' % groups if groups > 1 else ''
>         w = 'bias=1\n' if bias is not None and bn is not False else 'bias=0\n' if bias is None and bn is False else ''
> 
>         self.fc.write('\n[c2f]\n' +
>                       'n=%d\n' % n +
>                       'shortcut=%d\n' % shortcut +
>                       b +
219a156,160
>                       'size=%s\n' % self.get_value(size) +
>                       'stride=%s\n' % self.get_value(stride) +
>                       'pad=%s\n' % self.get_value(pad) +
>                       g +
>                       w +
222c163
<     def route(self, layers):
---
>     def route(self, layers, axis=0):
224a166,167
>         a = 'axis=%d\n' % axis if axis != 0 else ''
> 
226c169,170
<                       'layers=%s\n' % layers)
---
>                       'layers=%s\n' % layers +
>                       a)
259c203
<     def avgpool(self):
---
>     def shuffle(self, reshape=None, transpose1=None, transpose2=None):
262c206,213
<         self.fc.write('\n[avgpool]\n')
---
>         r = 'reshape=%s\n' % ', '.join(str(x) for x in reshape) if reshape is not None else ''
>         t1 = 'transpose1=%s\n' % ', '.join(str(x) for x in transpose1) if transpose1 is not None else ''
>         t2 = 'transpose2=%s\n' % ', '.join(str(x) for x in transpose2) if transpose2 is not None else ''
> 
>         self.fc.write('\n[shuffle]\n' +
>                       r +
>                       t1 +
>                       t2)
264c215
<     def yolo(self, i):
---
>     def yolo(self, child):
267,273c218,220
<         self.fc.write('\n[yolo]\n' +
<                       'mask=%s\n' % self.masks[i] +
<                       'anchors=%s\n' % self.anchors +
<                       'classes=%d\n' % self.nc +
<                       'num=%d\n' % self.num +
<                       'scale_x_y=2.0\n' +
<                       'new_coords=1\n')
---
>         self.fc.write('\n[detect_v8]\n' +
>                       'num=%d\n' % (child.reg_max * 4) +
>                       'classes=%d\n' % child.nc)
286,301c233,247
<     def get_anchors(self, state_dict, out_channels):
<         anchor_grid = state_dict['anchor_grid']
<         aa = anchor_grid.reshape(-1).tolist()
<         am = anchor_grid.tolist()
< 
<         self.num = (len(aa) / 2)
<         self.nc = int((out_channels / (self.num / len(am))) - 5)
<         self.anchors = str(aa)[1:-1]
< 
<         n = 0
<         for m in am:
<             mask = []
<             for _ in range(len(m)):
<                 mask.append(n)
<                 n += 1
<             self.masks.append(str(mask)[1:-1])
---
>     def get_anchors(self, anchor_points, stride_tensor):
>         vr = anchor_points.numpy()
>         self.fw.write('{} {} '.format('anchor_points', len(vr)))
>         for vv in vr:
>             self.fw.write(' ')
>             self.fw.write(struct.pack('>f', float(vv)).hex())
>         self.fw.write('\n')
>         self.wc += 1
>         vr = stride_tensor.numpy()
>         self.fw.write('{} {} '.format('stride_tensor', len(vr)))
>         for vv in vr:
>             self.fw.write(' ')
>             self.fw.write(struct.pack('>f', float(vv)).hex())
>         self.fw.write('\n')
>         self.wc += 1
310,321c256,260
<         if n < 0:
<             for i, b in enumerate(self.blocks[self.current-1::-1]):
<                 if i < abs(n) - 1:
<                     r -= b
<                 else:
<                     break
<         else:
<             for i, b in enumerate(self.blocks):
<                 if i <= n:
<                     r += b
<                 else:
<                     break
---
>         for i, b in enumerate(self.blocks):
>             if i <= n:
>                 r += b
>             else:
>                 break
335c274
<     parser = argparse.ArgumentParser(description='PyTorch YOLOv5 conversion')
---
>     parser = argparse.ArgumentParser(description='PyTorch YOLOv8 conversion')
338,339c277
<         '-s', '--size', nargs='+', type=int, help='Inference size [H,W] (default [640])')
<     parser.add_argument("--p6", action="store_true", help="P6 model")
---
>         '-s', '--size', nargs='+', type=int, default=[640], help='Inference size [H,W] (default [640])')
343,344d280
<     if not args.size:
<         args.size = [1280] if args.p6 else [640]
351,352c287,288
< wts_file = model_name + '.wts' if 'yolov5' in model_name else 'yolov5_' + model_name + '.wts'
< cfg_file = model_name + '.cfg' if 'yolov5' in model_name else 'yolov5_' + model_name + '.cfg'
---
> wts_file = model_name + '.wts' if 'yolov8' in model_name else 'yolov8_' + model_name + '.wts'
> cfg_file = model_name + '.cfg' if 'yolov8' in model_name else 'yolov8_' + model_name + '.cfg'
356,360d291
< 
< anchor_grid = model.model[-1].anchors * model.model[-1].stride[..., None, None]
< delattr(model.model[-1], 'anchor_grid')
< model.model[-1].register_buffer('anchor_grid', anchor_grid)
< 
362a294,298
> if model.names and model.nc:
>     with open("labels.txt", 'w') as fw:
>         for i in range(model.nc):
>             fw.write(model.names[i] + '\n')
> 
367,369c303
<         if child._get_name() == 'Focus':
<             layers.Focus(child)
<         elif child._get_name() == 'Conv':
---
>         if child._get_name() == 'Conv':
371,376c305,306
<         elif child._get_name() == 'BottleneckCSP':
<             layers.BottleneckCSP(child)
<         elif child._get_name() == 'C3':
<             layers.C3(child)
<         elif child._get_name() == 'SPP':
<             layers.SPP(child)
---
>         elif child._get_name() == 'C2f':
>             layers.C2f(child)
385,390c315,319
<         elif child._get_name() == 'CBH':
<             layers.CBH(child)
<         elif child._get_name() == 'LC_Block':
<             layers.LC_Block(child)
<         elif child._get_name() == 'Dense':
<             layers.Dense(child)
---
>             x = []
>             for stride in model.stride.tolist():
>                 x.append(torch.zeros([1, 1, int(layers.height / stride), int(layers.width / stride)], dtype=torch.float32))
>             anchor_points, stride_tensor = (x.transpose(0, 1) for x in make_anchors(x, child.stride, 0.5))
>             layers.get_anchors(anchor_points.reshape([-1]), stride_tensor.reshape([-1]))
